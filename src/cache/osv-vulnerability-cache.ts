import { isValidVulnerability } from '@utils/helpers';

const CACHE_TTL_MS = 24 * 60 * 60 * 1000;

type VulnerabilityRef = {
	id: string;
	modified?: string;
};

type CachedVulnerability = {
	fetchedAt: number;
	modified?: string;
	vulnerability: OSVVulnerability;
};

const vulnerabilityCache = new Map<string, CachedVulnerability>();
let hasLoadedCache = false;
let cacheLoadPromise: Promise<void> | null = null;
let cacheDirty = false;

const getCacheLocation = (): { filePath: string } | null => {
	const xdgCacheHome = Bun.env.XDG_CACHE_HOME;
	if (xdgCacheHome) {
		return {
			filePath: `${xdgCacheHome}/bun-guard/osv-vuln-cache.json`,
		};
	}

	const homeDir = Bun.env.HOME;
	if (homeDir) {
		return {
			filePath: `${homeDir}/.cache/bun-guard/osv-vuln-cache.json`,
		};
	}

	return null;
};

const isCacheEntryValid = (entry: CachedVulnerability, expectedModified?: string): boolean => {
	if (Date.now() - entry.fetchedAt > CACHE_TTL_MS) return false;
	if (expectedModified && entry.modified && entry.modified !== expectedModified) return false;
	if (expectedModified && !entry.modified) return false;

	return true;
};

const loadVulnerabilityCache = async (): Promise<void> => {
	if (hasLoadedCache) return;
	if (cacheLoadPromise) {
		await cacheLoadPromise;
		return;
	}

	cacheLoadPromise = (async () => {
		const cacheLocation = getCacheLocation();
		if (!cacheLocation) return;

		try {
			const cacheContent = await Bun.file(cacheLocation.filePath).text();
			if (!cacheContent) return;

			const cacheData = JSON.parse(cacheContent) as {
				entries?: Record<string, CachedVulnerability>;
			};
			if (!cacheData.entries) return;

			for (const [id, entry] of Object.entries(cacheData.entries)) {
				if (!entry || typeof entry !== 'object') continue;
				if (!isValidVulnerability(entry.vulnerability)) continue;
				if (typeof entry.fetchedAt !== 'number' || entry.fetchedAt <= 0) continue;

				const cachedEntry: CachedVulnerability = {
					fetchedAt: entry.fetchedAt,
					modified: typeof entry.modified === 'string' ? entry.modified : undefined,
					vulnerability: entry.vulnerability,
				};

				if (!isCacheEntryValid(cachedEntry)) {
					cacheDirty = true;
					continue;
				}

				vulnerabilityCache.set(id, cachedEntry);
			}
		} catch {
			return;
		} finally {
			hasLoadedCache = true;
		}
	})();

	await cacheLoadPromise;
	cacheLoadPromise = null;
};

const persistVulnerabilityCache = async (): Promise<void> => {
	if (!cacheDirty) return;

	const cacheLocation = getCacheLocation();
	if (!cacheLocation) return;

	try {
		const serializedEntries: Record<string, CachedVulnerability> = {};

		for (const [id, entry] of vulnerabilityCache) {
			if (!isCacheEntryValid(entry)) continue;
			serializedEntries[id] = entry;
		}

		await Bun.write(cacheLocation.filePath, JSON.stringify({ entries: serializedEntries }));
		cacheDirty = false;
	} catch {
		return;
	}
};

const getCachedVulnerabilityDetails = async (
	vulnerabilityRefs: VulnerabilityRef[],
): Promise<Map<string, OSVVulnerability>> => {
	await loadVulnerabilityCache();

	const cachedVulnerabilityDetails = new Map<string, OSVVulnerability>();
	const modifiedById = new Map<string, string | undefined>();

	for (const vulnerabilityRef of vulnerabilityRefs) {
		if (!modifiedById.has(vulnerabilityRef.id)) {
			modifiedById.set(vulnerabilityRef.id, vulnerabilityRef.modified);
		}
	}

	for (const [id, modified] of modifiedById) {
		const cachedEntry = vulnerabilityCache.get(id);
		if (!cachedEntry || !isCacheEntryValid(cachedEntry, modified)) {
			if (cachedEntry) {
				vulnerabilityCache.delete(id);
				cacheDirty = true;
			}

			continue;
		}

		cachedVulnerabilityDetails.set(id, cachedEntry.vulnerability);
	}

	return cachedVulnerabilityDetails;
};

const cacheVulnerabilityDetails = (
	vulnerabilityDetails: Map<string, OSVVulnerability>,
	vulnerabilityRefs: VulnerabilityRef[],
): void => {
	if (vulnerabilityDetails.size === 0) return;

	const modifiedById = new Map<string, string | undefined>();
	for (const vulnerabilityRef of vulnerabilityRefs) {
		if (!modifiedById.has(vulnerabilityRef.id)) {
			modifiedById.set(vulnerabilityRef.id, vulnerabilityRef.modified);
		}
	}

	const fetchTimestamp = Date.now();

	for (const [id, vulnerability] of vulnerabilityDetails) {
		vulnerabilityCache.set(id, {
			fetchedAt: fetchTimestamp,
			modified: modifiedById.get(id) || vulnerability.modified,
			vulnerability,
		});
	}

	cacheDirty = true;
};

export {
	type VulnerabilityRef,
	getCachedVulnerabilityDetails,
	cacheVulnerabilityDetails,
	persistVulnerabilityCache,
};
